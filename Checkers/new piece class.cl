(defclass piece ()
  (
   (owner :initarg :owner :initform -1)
   (location :initarg :location :initform '(-1 -1))
   (canJump :initarg :canJump :initform nil)
   (isKing :initarg :isKing :initform nil)
   (moveList :initarg :movelist :initform nil)
   )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;tooooo doooooooooooooo reverse the changes made in the recursive calls
(defmethod genMoveListR ((thePiece piece) theBoard theMovelist)
  (let ((hasJumped nil) (validlist '(nil nil nil nil)) (jumpCounter 0))
  (if (>= (length theMovelist) 2) 
      (setf hasjumped t)
    )
  (if (slot-value thePiece 'isKing) 
        (progn
          (let ((r (nth 0 (slot-value thePiece 'location))) (c (nth 1 (slot-value thePiece 'location))))
              (if (and (>= (- c 1) 0) (>= (- r 1) 0))
                  (setf (nth 0 validlist) (nth (- c 1) (nth (- r 1) theBoard)))
                (setf (nth 0 validlist) 0)
                )
            (if (and (<= (+ c 1) 7) (>= (- r 1) 0))
                (setf (nth 1 validlist) (nth (+ c 1) (nth (- r 1) theBoard)))
              (setf (nth 1 validlist) 0)
                )
            (if (and (<= (+ c 1) 7) (<= (+ r 1) 7))
                (setf (nth 2 validlist) (nth (+ c 1) (nth (+ r 1) theBoard)))
              (setf (nth 2 validlist) 0)
              )
            (if (and (>= (- c 1) 0) (<= (+ r 1) 7))
                (setf (nth 3 validlist) (nth (- c 1) (nth (+ r 1) theBoard)))
              (setf (nth 3 validlist) 0)
              )
              )
          )
    (if (= (slot-value thePiece 'owner) 1) ;;else (not a king)
        (progn
          (let ((r (nth 0 (slot-value thePiece 'location))) (c (nth 1 (slot-value thePiece 'location))))
          (if (and (>= (- c 1) 0) (>= (- r 1) 0))
                  (setf (nth 0 validlist) (nth (- c 1) (nth (- r 1) theBoard)))
                (setf (nth 0 validlist) 0)
                )
              (if (and (<= (+ c 1) 7) (>= (- r 1) 0))
                  (setf (nth 1 validlist) (nth (+ c 1) (nth (- r 1) theBoard)))
                (setf (nth 1 validlist) 0)
                )
            (setf (nth 2 validlist) 0)
            (setf (nth 3 validlist) 0)
            )
          )
      (progn ;;else it must be player 1 and player one wants to go positive on rows
        (let ((r (nth 0 (slot-value thePiece 'location))) (c (nth 1 (slot-value thePiece 'location))))
               (if (and (<= (+ c 1) 7) (<= (+ r 1) 7))
                  (setf (nth 2 validlist) (nth (+ c 1) (nth (+ r 1) theBoard)))
                (setf (nth 2 validlist) 0)
                )
              (if (and (>= (- c 1) 0) (<= (+ r 1) 7))
                  (setf (nth 3 validlist) (nth (- c 1) (nth (+ r 1) theBoard)))
                (setf (nth 3 validlist) 0)
                )
          )
        (setf (nth 0 validlist) 0)
        (setf (nth 1 validlist) 0)
        )
          )
    )
    (print validlist)
    (let ((myValidlist (copy-list validlist)))
    (dotimes (x (length validlist))
      (print "x =")
      (print x)
      (let ((item (nth x validlist)))
                (if (eq 'piece (type-of item))
                    (if (not (eq (slot-value item 'owner) (slot-value thePiece 'owner))) ;;If diff teams
                        ;; (where you are going - where you are) + where you are going
                        (progn
                          (print "item location")
                          (print (slot-value item 'location))
                          (let ((r (+ (- (nth 0 (slot-value item 'location)) (nth 0 (slot-value thePiece 'location))) (nth 0 (slot-value item 'location))))
                                (c (+ (- (nth 1 (slot-value item 'location)) (nth 1 (slot-value thePiece 'location))) (nth 1 (slot-value item 'location)))))
                            (if (and (>= r 0) (<= r 7) (>= c 0) (<= c 7)) ;;if inside bounds
                            (if (not (eq 'piece (type-of (nth c (nth r theBoard)))))
                                (progn 
                                  (let ((myBoard theBoard) (myMovelist theMovelist) (originalLocation (slot-value thePiece 'location)) (myPiece thePiece))
                                    (incf jumpcounter)
                                    (setf theMovelist (append theMovelist (list (list r c))))
                                    (updateBoard thePiece theBoard theMovelist)
                                    (genMoveListR thePiece theBoard theMovelist)
                                    (print "the new piece move list")
                                    (print (slot-value thePiece 'movelist))
                                    (setf validlist MyValidlist)
                                    (print "orginal validlist")
                                    (print validlist)
                                    (setf (nth (nth 1 (slot-value item 'location)) (nth (nth 0 (slot-value item 'location)) theboard)) item)
                                    (setf (nth c (nth r theboard)) nil)
                                    (setf theMovelist myMovelist)
                                    (setf thePiece myPiece)
                                    (setf (nth (nth 1 originallocation) (nth (nth 0 originallocation) theBoard)) thePiece)
                                    (setf (slot-value thePiece 'location) originalLocation)
                                  )
                              )
                              )
                            (setf (nth x validlist) 0)
                              )
                            
                          )
                          )
                      (setf (nth x validlist) 0)
                  )
                  )
                  )
      )
      (setf validlist myValidlist)
      )
    (if (and (not hasJumped) (= 0 jumpCounter))
        (progn
          (let ((nonnil (remove nil (remove 0 validlist))))
            (if (= 0 (length nonnil))
                (progn
                  (print "adding empty locations to list")
                  (print (slot-value thePiece 'location))
                  (dotimes (x (length validlist))  
                    (let ((tempList ()))
                      (if (eq nil (nth x validlist))
                          (progn
                            (if (= x 0)
                                (progn
                                  (print (list (- (nth 0 (slot-value thePiece 'location)) 1) (- (nth 1 (slot-value thePiece 'location)) 1)))
                                  (setf templist (append templist (list (slot-value thePiece 'location) (list (- (nth 0 (slot-value thePiece 'location)) 1) (- (nth 1 (slot-value thePiece 'location)) 1)))))
                                  )
                              )
                            (if (= x 1)
                                (setf templist (append templist (list (slot-value thePiece 'location) (list (- (nth 0 (slot-value thePiece 'location)) 1) (+ (nth 1 (slot-value thePiece 'location)) 1)))))
                              )
                            (if (= x 2)
                                (setf templist (append templist (list (slot-value thePiece 'location) (list (+ (nth 0 (slot-value thePiece 'location)) 1) (+ (nth 1 (slot-value thePiece 'location)) 1)))))
                              )
                            (if (= x 3)
                                (setf templist (append templist (list (slot-value thePiece 'location) (list (+ (nth 0 (slot-value thePiece 'location)) 1) (- (nth 1 (slot-value thePiece 'location)) 1)))))
                              )
                            )
                        )
                      (print "the templist")
                      (print templist)
                      (print "the piece movelist")
                      (print (slot-value thePiece 'movelist))
                      (if (not (eq nil templist))
                          (progn
                            (setf (slot-value thePiece 'movelist) (remove templist (slot-value thePiece 'movelist) :test #'equal))
                            (setf (slot-value thePiece 'movelist) (append (slot-value thePiece 'movelist) (list templist)))
                            )
                        )
                      )
                    )
                  )
              )
            )
          )
      (if (and (= jumpcounter 0) hasJumped)
          (progn
            (print "updating piece master move list with new jumps")
            ;;(setf theMovelist (append theMovelist (slot-value thePiece 'location)))
            (print "themovelist")
            (print theMovelist)
            (print "the piece movelist")
            (print (slot-value thePiece 'movelist))
            (if (not (member themovelist (slot-value thePiece 'movelist)))
                (progn
                  ;;(setf (slot-value thePiece 'movelist) (remove (list theMovelist) (slot-value thePiece 'movelist) :test #'equal))
                  ;;(setf (slot-value thePiece 'movelist) (remove nil (slot-value thePiece 'movelist)))
                  (setf (slot-value thePiece 'movelist) (append (slot-value thePiece 'movelist) (list theMovelist)))
                  )
              )
            )
        )
      )
    )
  )
          
    
  
