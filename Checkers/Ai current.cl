(defun aiDecision (theBoard level)  ;;;top level function that returns the movelist chosen by the AI 
  ;;the board is the current state of the board
  ;;level is how many turns to simulate
  (setf utilitylist ())
  (setf resultlist ())
  (let ((myBoard (copy-list theBoard)))
    (setf aiMovelist (list (aimax theBoard level)))
    (setf random-state (make-random-state t))
    (setf x (random (length aiMovelist)))
    (setf result (nth x aiMovelist)) ;;return
    (setf theBoard myBoard)
    )
  )

(defun aimax (theBoard level) ;;max is owner 0
  (updateAllPieces theBoard)
  (if (= 0 level) ;;base case 
      ;;loops through the board updating the moves of all pieces
      (progn
        (let ((listofmoves ()) (longestMove 0))
        (dotimes (r 8)
          (dotimes (c 8)
            (let ((p (nth c (nth r theBoard))))
              (if (eq 'piece (type-of p))
                  (if (= 0 (slot-value p 'owner))
                  (progn
                      (dotimes (x (length (slot-value p 'movelist)))
                        (if (> (length (nth x (slot-value p 'movelist))) longestMove)
                            (setf longestmove (length (nth x (slot-value p 'movelist))))
                          )
                        )   
                      )  
                    )
                    )
                )
              )
          )
          (setf longestMove longestMove)
          )
          )
    (progn ;;recursive case
      (progn
        (let ((listofmoves ()))
        (dotimes (r 8)
          (dotimes (c 8)
            (let ((p (nth c (nth r theBoard))))
              (if (eq 'piece (type-of p))
                  (if (= 0 (slot-value p 'owner))
                  (progn
                    (let ((longestMove 0))
                      (dotimes (x (length (slot-value p 'movelist)))
                        (if (> (length (nth x (slot-value p 'movelist))) longestMove)
                            (setf longestmove (length (nth x (slot-value p 'movelist))))
                          
                          )
                        )
                      (dotimes (x (length (slot-value p 'movelist)))
                        ;;(if (= (length (nth x (slot-value p 'movelist))) longestMove)
                            (setf listofmoves (append listofmoves (list (nth x (slot-value p 'movelist)))))
                          ;;)
                        )
                      (let ((listofjumps ()))
                        (dotimes (x (length listofmoves))
                          (if (= (+ (abs (- (nth 1 (nth 0 (nth x listofmoves))) (nth 1 (nth 1 (nth x listofmoves))) )) (abs (- (nth x (nth 0 (nth 0 listofmoves))) (nth 0 (nth 1 (nth x listofmoves))) ))) 4)
                              (setf listofjumps (append listofjumps (list (nth x listofmoves))))
                            )
                          )
                        (if (> 0 (length listofjumps))
                            (setf listofmoves listofjumps)
                          )
                        )
                      (setf utilitylist ())
                      (dotimes (x (length listofmoves))
                        (let ((myBoard (copy-list theBoard)))
                          (updateboard p theBoard (nth x listofmoves))
                          (setf utilitylist (append utilitylist (list (aimin theBoard (- level 1)))))
                          (setf theBoard myBoard)
                          )
                        )
                      (setf resultlist ())
                      (setf greatestutility 0)
                      (dotimes (x (length utilitylist))
                        (if (> (nth x utilitylist) greatestutility)
                            (setf greatestutility (nth x utilitylist))
                          )
                        )
                      (dotimes (x (length utilitylist))
                        (if (= (nth x utilitylist) greatestutility)
                            (setf resultlist (append resultlist (list (nth x listofmoves))))
                          )
                        )
                    )
                )
              )
            )
          )
          (setf resultlist resultlist) ;;return the longest move possible
          )
          )
          )
        )
      )
    )
  )




(defun aimin (theBoard level) ;;min is owner 1
  (updateAllPieces theBoard)
  (if (= 0 level) ;;base case 
      ;;loops through the board updating the moves of all pieces
      (progn
        (let ((listofmoves ()) (longestMove 0))
        (dotimes (r 8)
          (dotimes (c 8)
            (let ((p (nth c (nth r theBoard))))
              (if (eq 'piece (type-of p))
                  (if (= 1 (slot-value p 'owner))
                  (progn
                    (dotimes (x (length (slot-value p 'movelist)))
                      (if (> (length (nth x (slot-value p 'movelist))) longestMove)
                          (setf longestmove (length (nth x (slot-value p 'movelist))))
                        )
                      )  
                    )  
                    )
                    )
                )
              )
          )
          (setf longestMove (* -1 longestMove)) ;;return the longest move possible
          )
          )
    (progn ;;recursive case
      (progn
        (let ((listofmoves ()))
        (dotimes (r 8)
          (dotimes (c 8)
            (let ((p (nth c (nth r theBoard))))
              (if (eq 'piece (type-of p))
                  (if (= 1 (slot-value p 'owner))
                  (progn
                    (let ((longestMove 0))
                      (dotimes (x (length (slot-value p 'movelist)))
                        (if (> (length (nth x (slot-value p 'movelist))) longestMove)
                            (setf longestmove (length (nth x (slot-value p 'movelist))))
                          
                          )
                        )
                      (dotimes (x (length (slot-value p 'movelist)))
                        ;;(if (= (length (nth x (slot-value p 'movelist))) longestMove)
                            (setf listofmoves (append listofmoves (list (nth x (slot-value p 'movelist)))))
                         ;; )
                        )
                      (let ((listofjumps ()))
                        (dotimes (x (length listofmoves))
                          (if (= (+ (abs (- (nth 1 (nth 0 (nth x listofmoves))) (nth 1 (nth 1 (nth x listofmoves))) )) (abs (- (nth 0 (nth 0 (nth x listofmoves))) (nth 0 (nth 1 (nth x listofmoves))) ))) 4)
                              (setf listofjumps (append listofjumps (list (nth x listofmoves))))
                            )
                          )
                        (if (> 0 (length listofjumps))
                            (setf listofmoves listofjumps)
                          )
                        )
                      (setf utilitylist ())
                      (dotimes (x (length listofmoves))
                        (let ((myBoard (copy-list theBoard)))
                          (updateboard p theBoard (nth x listofmoves))
                          (setf utilitylist (append utilitylist (list (aimax theBoard (- level 1)))))
                          (setf theBoard myBoard)
                          )
                        )
                      (setf resultlist ())
                      (setf greatestutility 0)
                      (dotimes (x (length utilitylist))
                        (if (> (nth x utilitylist) greatestutility)
                            (setf greatestutility (nth x utilitylist))
                          )
                        )
                      (dotimes (x (length utilitylist))
                        (if (= (nth x utilitylist) greatestutility)
                            (setf resultlist (append resultlist (list (nth x listofmoves))))
                          )
                        )
                    )
                )
              )
            )
          )
          (setf resultlist resultlist) ;;return the longest move possible
          )
          )
          )
        )
      )
    )
  )
  
