(defun aiDecision (theBoard owner level) ;;higher level is more levels down in recursion
  (let ((moveDecision ()) (utilityList ()) (allvalidmoves (allmoves owner theBoard)))
    (let ((tempboard (copyboard theboard)))
      (setf moveDecision (aiMax tempboard owner level))
      )
    moveDecision
    )
  )

(defun aiMax (theBoard owner level) ;; this function returns the move with the highest utility
  (let ((moveDecision ()) (utilityList ()) (allvalidmoves (allmoves owner theBoard)) (highest -99999))
    (if (> (length allvalidmoves) 0)
        (progn
        ;;(print "All Valid Moves -- max")
        ;;(print allvalidmoves)
          (dotimes (x (length allvalidmoves))
            (let* ((tempboard (copyboard theboard)) (alteredBoard (copyboard theBoard)) (move (nth x allvalidmoves)))
              ;;(print "move -- max")
              ;;(print move)
              (updateboard (boarditemat alteredboard (nth 0 move)) alteredboard move)
              (if (> level 0)
                  (setf utilitylist (append utilitylist (list (utility owner tempboard (aiMin alteredboard (mod (+ owner 1) 2) (- level 1))))))
                (setf utilitylist (append utilitylist (list (utility owner tempboard move))))
                )
              (if (< highest (nth x utilitylist))
                  (setf highest (nth x utilitylist))
                )
              )
            )
          ;;(print "utility list -- max")
          ;;(print utilitylist)
          (dotimes (x (length utilitylist))
            (if (= (nth x utilitylist) highest)
                (setf movedecision (append moveDecision (list (nth x allvalidmoves))))
              )
            )
          ;;(print "move decision --max ")
          ;;(print movedecision)
          (nth (random (length movedecision)) movedecision)
          )
      '(((7 7) (0 0)))
      )
    )
  )

(defun aiMin (theBoard owner level)
  (let ((moveDecision ()) (utilityList ()) (allvalidmoves (allmoves owner theBoard)) (highest -99999))
    (if (> (length allvalidmoves) 0)
        (progn
          ;;(print "All Valid Moves -- min")
          ;;(print allvalidmoves)
          (dotimes (x (length allvalidmoves))
            (let* ((tempboard (copyboard theboard)) (alteredBoard (copyboard theBoard)) (move (nth x allvalidmoves)))
              ;;(print "move -- min")
              ;;(print move)
              (updateboard (boarditemat alteredboard (nth 0 move)) alteredboard move)
              (if (> level 0)
                  (setf utilitylist (append utilitylist (list (utility owner tempboard (aiMax alteredboard (mod (+ owner 1) 2) (- level 1))))))
                (setf utilitylist (append utilitylist (list (utility owner tempboard move))));;else
                )
              (if (< highest (nth x utilitylist)) ;;Note: Utilitylist is not properly staying a list of elemts if it only contains one element./ 
                  (setf highest (nth x utilitylist))
                )
              )
            )
          ;;(print "utility list -- min")
          ;;(print utilitylist)
          (dotimes (x (length utilitylist))
            (if (= (nth x utilitylist) highest)
                (setf movedecision (append moveDecision (list (nth x allvalidmoves))))
              )
            )
          ;;(print "move decision -- min")
          ;;(print movedecision)
          (nth (random (length movedecision)) movedecision)
          )
      '(((0 0) (7 7)))
      )
    )
  )

